#![no_std]

mod tests;

use soroban_sdk::{contractevent, Address, BytesN, String};

// Events that are a special case generated by the Stellar Asset Contract, but are part of SEP-41,
// but are not expected to be generated by other contracts. Defined here privately only for the
// purpose of generating the complete contract spec.

/// Transfer event published when a classic payment uses the MEMO_TEXT memo type.
#[contractevent(topics = ["transfer"], data_format = "map", export = false)]
#[doc(hidden)]
pub struct TransferWithMuxedString {
    #[topic]
    pub from: Address,
    #[topic]
    pub to: Address,
    pub to_muxed_id: Option<String>,
    pub amount: i128,
}

/// Transfer event published when a classic payment uses the MEMO_HASH or MEMO_RETURN memo type.
#[contractevent(topics = ["transfer"], data_format = "map", export = false)]
#[doc(hidden)]
pub struct TransferWithMuxedBytes {
    #[topic]
    pub from: Address,
    #[topic]
    pub to: Address,
    pub to_muxed_id: Option<BytesN<32>>,
    pub amount: i128,
}

/// Mint event published when a classic payment uses the MEMO_TEXT memo type.
#[contractevent(topics = ["mint"], data_format = "map", export = false)]
#[doc(hidden)]
pub struct MintWithMuxedString {
    #[topic]
    pub to: Address,
    pub to_muxed_id: Option<String>,
    pub amount: i128,
}

/// Mint event published when a classic payment uses the MEMO_HASH or MEMO_RETURN memo type.
#[contractevent(topics = ["mint"], data_format = "map", export = false)]
#[doc(hidden)]
pub struct MintWithMuxedBytes {
    #[topic]
    pub to: Address,
    pub to_muxed_id: Option<BytesN<32>>,
    pub amount: i128,
}

pub(crate) const XDR_INPUT: &[&[u8]] = &[
    &soroban_sdk::token::TokenFnSpec::spec_xdr_allowance(),
    &soroban_sdk::token::TokenFnSpec::spec_xdr_approve(),
    &soroban_sdk::token::TokenFnSpec::spec_xdr_balance(),
    &soroban_sdk::token::TokenFnSpec::spec_xdr_burn(),
    &soroban_sdk::token::TokenFnSpec::spec_xdr_burn_from(),
    &soroban_sdk::token::TokenFnSpec::spec_xdr_decimals(),
    &soroban_sdk::token::TokenFnSpec::spec_xdr_name(),
    &soroban_sdk::token::TokenFnSpec::spec_xdr_symbol(),
    &soroban_sdk::token::TokenFnSpec::spec_xdr_transfer(),
    &soroban_sdk::token::TokenFnSpec::spec_xdr_transfer_from(),
    &soroban_token_sdk::events::Approve::spec_xdr(),
    &soroban_token_sdk::events::TransferWithAmountOnly::spec_xdr(),
    &soroban_token_sdk::events::Transfer::spec_xdr(),
    &TransferWithMuxedString::spec_xdr(),
    &TransferWithMuxedBytes::spec_xdr(),
    &soroban_token_sdk::events::Burn::spec_xdr(),
    &soroban_token_sdk::events::MintWithAmountOnly::spec_xdr(),
    &soroban_token_sdk::events::Mint::spec_xdr(),
    &MintWithMuxedString::spec_xdr(),
    &MintWithMuxedBytes::spec_xdr(),
    &soroban_token_sdk::events::Clawback::spec_xdr(),
];

pub(crate) const XDR_LEN: usize = 6620;

/// Returns the contract spec for a SEP-41 Token contract.
pub const fn xdr() -> &'static [u8] {
    &XDR
}

/// The contract spec for a SEP-41 Token contract.
const XDR: [u8; XDR_LEN] = {
    let input = XDR_INPUT;
    // Concatenate all XDR for each item that makes up the token spec.
    let mut output = [0u8; XDR_LEN];
    let mut input_i = 0;
    let mut output_i = 0;
    while input_i < input.len() {
        let subinput = input[input_i];
        let mut subinput_i = 0;
        while subinput_i < subinput.len() {
            output[output_i] = subinput[subinput_i];
            output_i += 1;
            subinput_i += 1;
        }
        input_i += 1;
    }

    // Check that the numbers of bytes written is equal to the number of bytes
    // expected in the output.
    if output_i != output.len() {
        panic!("unexpected output length",);
    }

    output
};
